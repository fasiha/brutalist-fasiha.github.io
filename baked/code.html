<!DOCTYPE html>
<title>code *** aldebrn.me</title>
<meta charset="UTF-8">
<style>
@font-face {
 font-family: 'fira_codelight';
 src: url('firacode-light-webfont.woff') format('woff');
 font-weight: normal;
 font-style: normal;
}
body {
 margin-left: 2em;
 display: flex;
 flex-direction: row;
 font-size: 1.2em;
 font-family: "fira_codelight";
}

.body {
 flex-direction: row;
 display: flex;
 flex: 1;
}
.nav {
 order: -1;
 flex: 0 0 12em;
}
.content {
 padding-left: 0.5em;
 padding-right: 0.5em;
 background: rgb(239,238,234);
 flex: 1;
 max-width: 50ex;
}
@media (max-width: 768px) {
 .body {
  flex-direction: column;
  display: flex;
  flex: 1;
 }
 .nav {
  flex: 0 0 1em;
 }
}
.nav li {
 list-style-type:none;
 padding-left:0;
}
article {
 line-height: 1.19em;
}
blockquote p {
 hanging-punctuation: first;
 text-indent: 2em;
}
figcaption {
 font-size: 0.9em;
}
a, code {
color: rgb(0,67,196)
}
code {
 font-family: "fira_codelight";
}
matlab {
 font-variant: small-caps;
}
matlab::before {
 content: "Matlab";
}
pre {
 max-width: 80em;
 font-size: 0.875em;
 background: white;
}
</style>
<body>
 <div class="body">
  <article class="content">
 <header>
  <h2>Insight !== Numbers. Code.</h2>
 </header>

 <section>
  <h1><matlab></matlab>~~~Replicate columns of a matrix unequal numbers of times</h1>
  <p>We’ve got a matrix <code>P</code>. In <matlab></matlab>, this means a 2D array of numbers. It has  <code>widthP</code> columns and the number of rows doesn’t matter. We need a second matrix <code>M</code> that contains each column of the first matrix, <code>P</code>, repeated an arbitrary number of times. A vector <code>reps</code>, containing <code>widthP</code> entries, tells you how many times any given column of <code>P</code> is replicated.</p>

  <p>E.g. If <code>P = [42 -1 101]</code> and <code>reps = [4 2 3]</code>, we want <code>M = [42 42 42 42 -1 -1 101 101 101]</code>, assuming I typed that correctly.</p>

  <p>We had a working implementation that profiling revealed to be a bottleneck. Here’s how we went about optimizing this.</p>

  <p>§1~&gt;create a standalone script which sets up some random data, and a correct implementation. The one here is simpler than the technique we started out with.</p>

  <pre><code>P = [42 -1 101];
reps = [2 1 5];

widthP = length(reps);
M = [];
for colIdx = 1 : length(reps)
  M = [M repmat(P(:, colIdx), 1, reps(colIdx))];
end</code></pre>

  <p>N.B. As (unwilling) professional Matlab writers, we wouldn’t have written this to start out with since (i), <code>for</code> loops are still best avoided in <matlab></matlab> (“Instead of writing loop-based code, consider using MATLAB matrix and vector operations” <a href="http://www.mathworks.com/help/matlab/matlab_prog/techniques-for-improving-performance.html">[Mathworks]</a>), and (ii) re-allocating storage every iteration will be slow in any system.</p>

  <p>§2~&gt;find ways to do the same thing faster. Here’s the approach we actually started out with:
  <pre><code>c = arrayfun(@(n, i) i*ones(n,1), reps, 1:widthP, 'un', 0);
i = cell2mat(c(:));
M2 = P(:, i);
assert(all(M2(:) == M(:)))</code></pre>
  <code>arrayfun</code> <a href="http://www.mathworks.com/help/matlab/ref/arrayfun.html">[Mathworks]</a> is a lame <code>map</code>: taking a function handle (viz., <code>@(n, i) i*ones(n,1)</code>) and any number of arrays, and returning a cell array~~~which are <matlab></matlab>’s arbitrary-type arrays.</p>

  <p>What we’re doing here is building a vector <code>i</code>, with repeated values, which we’ll use to index into our original array <code>P</code>. This does what we need because in <matlab></matlab>, indexing an array with a vector containing repeats produces a result array containing repeats. Same story in Python/Numpy:
  <pre><code>import numpy as np
np.array([10, 20, 30])[[0,1,2,1,0,1,2]]
#=> array([10, 20, 30, 20, 10, 20, 30])</code></pre>
  and Julia:
  <pre><code>[10 20 30][[1 2 3 2 1 2 3]]
#=> 1x7 Array{Int64,2}:
#    10  20  30  20  10  20  30</code></pre>
  </p>

  <p>Using an index vector like this does indeed work: we compare <code>M2</code> to <code>M</code> (generated by the first implementation): <code>assert(all(M2(:) == M(:)))</code>. <code>assert</code> is a common function across programming languages that unceremoniously throws an error (halting program execution) if its argument is false.</p>

  <p>This way of building a big matrix out of a smaller matrix using an index vector is a really fast way to build that big matrix. We knew that because profiling showed the bottleneck to be before indexing into <code>P</code>. So we just need to find a way to efficiently build this index vector <code>i</code>.</p>

  <p>As mentioned above, this was actually the code we started out with. Why would it be a bottleneck? From the days of Tom Minka’s Lightspeed package <a href="http://research.microsoft.com/en-us/um/people/minka/software/lightspeed/">[Microsoft Research]</a>, we’ve known that the built-in <code>repmat</code> and even <code>ones</code> can be inefficient (<code>bsxfun</code> FTW!). Also, empirical experience over the years tells me that <code>cell2mat</code> makes things unfast.</p>

  <p>I started sketching~~~you know, pen and paper. A few minutes later, I had something fast but unreadable. I’ll show it in a second, but here’s the central idea. Remember the example we started out with, <code>reps = [4 2 3]</code>. The index vector we want to make is:
  $$
  i = \begin{bmatrix}
  1 \\ 1 \\ 1 \\ 1 \\ 
  2 \\ 2 \\
  3 \\ 3 \\ 3
  \end{bmatrix} 
  = cumsum\left(
  \begin{bmatrix}
  1 \\ 0 \\ 0 \\ 0 \\
  1 \\ 0 \\
  1 \\ 0 \\ 0
  \end{bmatrix}
  \right)
  ,
  $$
  where <code>cumsum</code> is the cumulative sum (a.k.a. prefix sum, scan, …). Looking at the vector being cumulatively summed (the second vector to the right), it dawned on me that it’s mostly zero, and has ones at the places where a new group of indexes begins, i.e., between 1 and 2, and between 2 and 3. If I could generate this boolean vector of zeros-and-ones efficiently, and betting that <code>cumsum</code> is fast in <matlab></matlab>, this could be an efficient way to generate the index vector <code>i</code>. I called the boolean vector <code>z</code> (“zeros, mostly” as the mnemonic).
  </p>

  <p>This next part is a little ugly. I could have logically and formally reasoned out how to calculate which indexes of a vector-of-zeros to flip on to obtain <code>z</code>. I couldn’t be bothered with all that, so I tried something that worked for this example: I notice that the indexes of ones in <code>z</code> (the vector inside <code>cumsum</code> above) are closely related to <code>reps = [4 2 3]</code>. The rule seemed to involve <code>reps</code>, another <code>cumsum</code>, don’t forgot to ignore the last element to get the dimensions to line up… The rule I came up with turns out to work in the general case.</p>

  <pre><code>widthM = sum(reps);
% vector to be cumsummed
z = zeros(widthM, 1);
% indexes of z to be 1 (otherwise z is 0)
j = [1 1+cumsum(reps(1:end-1))]; % pixie dust, not much
z(j) = 1;
% as promised, cumsum z to get i:
i = cumsum(z);
% use i to index into P:
M3 = P(:, i);
% Works right?
assert(all(M3(:) == M(:)))</code></pre>

  <p>The code (minus the comments) follows the stream-of-consciousness narrative above because it was written during it. The pixie dust in finding the indexes of non-zero <code>z</code> (<code>j</code> above, because it’s an index like <code>i</code>)~~~it works, but it’s not easy to see or to explain. Days like this I’m grateful I’m in industry and not academia and can let mysteries remain mysteries. (Actually, on all days I’m grateful I’m in industry.)</p>

  <p>Actually, this code doesn’t work in the absolute general case, when <code>reps</code> contains 0, i.e., when a column of the input array <code>P</code> doesn’t appear in the expanded array <code>M</code>. The code fails in an interesting way, but the fix isn’t that interesting: filter <code>reps</code> to be non-zero, run the above algorithm to generate <code>i</code> and shift it around to account for those 0-repeated indexes to get a corrected index vector <code>i2</code>. Here’s that full code:</p>

  <pre><code>nzidx = reps~=0;
nzreps = reps(nzidx);

% reps != 0 algorithm as above, except using nzreps instead of reps
widthM = sum(reps);
z = zeros(widthM, 1);
j = [1 1+cumsum(nzreps(1:end-1))]; % pixie dust, not much
z(j) = 1;
i = cumsum(z);

% adjust i
n = 1:numel(reps);
f = n(nzidx);
i2 = f(i);

M3 = P(:, i2);
assert(all(M3(:) == M(:)))</code></pre>

  <p>3~&gt;now that we had a couple of alternative implementations that we hope are fast, it’s time to benchmark speed and test generality.</p>

  <p><matlab></matlab> is an exceedingly clumsy language: anonymous functions are single expressions, and so cannot contain <code>if</code>, <code>for</code>, multiple statements of any kind (same story in Python, but that has other features that lessen the pain, without eliminating it). Matlab assignment and indexing have to be statements. Matlab requires (sub)functions to be defined in a function file, not a script file. (JavaScript and Clojure are far less brutal languages.)</p>

  <p>As a result of this complex of inadequacies (to which we’ve long resigned ourselves), we had to convert our simple easy-to-understand script file to a more opaque and less flexible function file. You can read it in full at its <a href="https://gist.github.com/fasiha/b5e8b1d61886cbe2583febde6a3fb42f">[Gist]</a>. A software carpentry aspect I want to point out is timing in <matlab></matlab>: after checking that all three methods yield the correct answer for large, randomly generated inputs, we used <code>timeit</code> to run each implementation many times, and normalize the runtimes by the first implementation.</p>

  <pre><code>t1 = timeit(@() method1(reps, P));
t2 = timeit(@() method2(reps, P));
t3 = timeit(@() method3(reps, P));
relativeTimes = [t1 t2 t3] / t1</code></pre>

  <p>We found that, for <code>P</code> 10×1000, and each of the thousand columns repeated between 0 and 39 times,
  <ul>
   <li>method 2 (<code>arrayfun</code>, <code>cell2mat</code>) runtime is 1.4× (slower!) than method 1, and</li>
   <li>method 3 (pixie dust, <code>cumsum</code>) runtime is 0.08× (much faster!) than method 1.</li>
  </ul>
  Compared to the code we originally started out with (method 2 here), the final code runs 14× faster. Now, many other parts of the application dominate runtime, but not this part.
  </p>

  <p>In summary, the three steps we followed, and that I’ve done countless times, are (nulla) profile to see what’s slow, then (i) carve out that piece into its own file, with some test data and a reference implementation. The next two steps, while presented above as serial, can (and were, partially) done in parallel: (ii) think very hard and find ways to make it go faster while remaining correct, and (iii) time the code. (ii) and (iii) can be repeated several times.</p>

  <p>Postscript. The above discussion presumes that you are lucky enough to identify a juicy candidate for optimization. In <matlab></matlab>, with mostly-math code, this is often the case in my experience. In larger applications that do many things besides number-crunching, the inefficiencies may be spread throughout the codebase. A reasonable statement of the two schools of thought is via one of Karsten Schmidt’s workshop report <a href="https://medium.com/@thi.ng/workshop-report-hi-perf-clojurescript-with-webgl-asm-js-and-emscripten-a545cca083bc#.7tp0znhyn">[Medium]</a>.</p>

  <p>Post-postscript. <code>timeit</code> was submitted to <a href="http://www.mathworks.com/matlabcentral/fileexchange/18798">[Mathworks File Exchange]</a> in 2008 and made it into <matlab></matlab> proper in 2013. Python 2.3, from 2003, had this built-in.</p>

 </section>

</article>
<script src='https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML' async></script>


  <div class="nav">
   <ul>
    <li><a href="index.html">top</a></li>
    <li><a href="code.html">code</a></li>
    <li><a href="maps.html">maps</a></li>
    <li><a href="math.html">math</a></li>
    <li><a href="misc.html">misc</a></li>
    <li><a href="about.html">about</a></li>
   </ul>
  </div>
 </div>
</body>
